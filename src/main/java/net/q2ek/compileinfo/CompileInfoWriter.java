package net.q2ek.compileinfo;

import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.time.LocalDate;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Properties;
import java.util.Set;

import javax.tools.FileObject;

public class CompileInfoWriter {
	private final Writer writer;
	private final Properties properties;

	CompileInfoWriter(Writer writer) {
		this.writer = writer;
		this.properties = System.getProperties();
	}

	/**
	 * @throws IOException
	 *             when FileObject cannot be used.
	 * @throws IOProblem
	 *             when {@link IOException} happens
	 */
	static void writeFile(String packageName, String name, FileObject resource) throws IOException {
		try (OutputStream stream = resource.openOutputStream();
				OutputStreamWriter writer = new OutputStreamWriter(stream)) {
			new CompileInfoWriter(writer).write(packageName, name);
			writer.flush();
		}
	}

	/**
	 * @throws IOProblem
	 *             when {@link IOException} happens
	 */
	private void append(CharSequence value) {
		try {
			this.writer.append(value);
		} catch (IOException e) {
			throw new IOProblem("Could not append to writer " + this.writer + " value " + value, e);
		}
	}

	void write(String packageName, String name) {
		append("package " + packageName + ";\n\n");
		append("import java.util.HashMap;\n");
		append("import java.util.Map;\n");
		append("import java.util.Set;\n");
		append("\n");
		addJavaDoc();
		append("public class " + name + "\n");
		append("{\n");
		writeDateTime();
		writeUser();
		writePropertiesMap();
		writeProperties();
		writeKeySetMethod();
		writePropertiesMapCreater();
		append("}\n");
	}

	private void addJavaDoc() {
		append("/**\n");
		append(" * @author Generated by " + CompileInfoAnnotationProcessor.class.getCanonicalName() + "\n");
		append(" * @see " + CompileInfo.class.getSimpleName() + "\n");
		append(" */\n");
	}

	private void writeDateTime() {
		append("    static String time() {\n");
		append("        return \"" + LocalDate.now() + " " + LocalTime.now() + "\";\n");
		append("    }\n\n");
	}

	private void writeUser() {
		append("    static String user() {\n");
		append("        return \"" + System.getProperty("user.name") + "\";\n");
		append("    }\n\n");
	}

	private void writePropertiesMap() {
		append("    private static final Map<String, String> properties = createMap();\n\n");
	}

	private void writePropertiesMapCreater() {
		append("    private static Map<String, String> createMap() {\n");
		append("        Map<String, String> result = new HashMap<>();\n");
		List<String> keys = sortedKeys(this.properties);
		for (String key : keys) {
			append(String.format("        result.put(\"%s\", \"%s\");\n", key, filter(this.properties.get(key).toString())));
		}
		append("        return result;\n");
		append("    }\n\n");
	}

	private static List<String> sortedKeys(Properties properties) {
		Set<Object> keySet = properties.keySet();
		List<String> keys = new ArrayList<>(keySet.size());
		keySet.forEach(key -> keys.add(key.toString()));
		Collections.sort(keys);
		return keys;
	}

	private void writeProperties() {
		append("    static String get(String key) {\n");
		append("        return properties.get(key);\n");
		append("    }\n\n");
	}

	private void writeKeySetMethod() {
		addJavaDocToKeySetMethod();
		append("    static Set<String> keySet() {\n");
		append("        return properties.keySet();\n");
		append("    }\n\n");
	}

	private void addJavaDocToKeySetMethod() {
		append("    /**\n");
		append("     * @returns<br/>\n");
		List<String> keys = sortedKeys(this.properties);
		keys.forEach(key -> append("     * " + key + "<br/>\n"));
		append("     */\n");
	}

	private static String filter(String value) {
		return value.replaceAll("\n", "\\\\n").replaceAll("\r", "\\\\r");
	}
}
